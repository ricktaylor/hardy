use super::*;

impl Dispatcher {
    #[cfg_attr(feature = "tracing", instrument(skip(self, data)))]
    pub async fn local_dispatch(
        self: &Arc<Self>,
        mut source: Eid,
        mut destination: Eid,
        data: Bytes,
        lifetime: std::time::Duration,
        flags: Option<services::SendOptions>,
    ) -> Result<hardy_bpv7::bundle::Id, services::Error> {
        // Check to see if we should use ipn 2-element encoding
        if self.ipn_2_element.iter().any(|p| p.matches(&destination)) {
            if let Eid::Ipn {
                fqnn,
                service_number,
            } = source
            {
                source = Eid::LegacyIpn {
                    fqnn,
                    service_number,
                };
            }

            if let Eid::Ipn {
                fqnn,
                service_number,
            } = destination
            {
                destination = Eid::LegacyIpn {
                    fqnn,
                    service_number,
                };
            }
        }

        // Build the bundle
        let bundle = loop {
            let mut builder =
                hardy_bpv7::builder::Builder::new(source.clone(), destination.clone())
                    .with_lifetime(lifetime);

            // Set flags
            if let Some(flags) = &flags {
                builder = builder.with_flags(hardy_bpv7::bundle::Flags {
                    do_not_fragment: flags.do_not_fragment,
                    app_ack_requested: flags.request_ack,
                    report_status_time: flags.report_status_time,
                    receipt_report_requested: flags.notify_reception,
                    forward_report_requested: flags.notify_forwarding,
                    delivery_report_requested: flags.notify_delivery,
                    delete_report_requested: flags.notify_deletion,
                    ..Default::default()
                });

                if flags.notify_reception
                    || flags.notify_forwarding
                    || flags.notify_delivery
                    || flags.notify_deletion
                {
                    builder =
                        builder.with_report_to(self.node_ids.get_admin_endpoint(&destination));
                }
            }

            let (bundle, data) = builder
                .with_payload(std::borrow::Cow::Borrowed(&data))
                .build(hardy_bpv7::creation_timestamp::CreationTimestamp::now())
                .map_err(|e| services::Error::Internal(e.into()))?;

            // Store to store
            if let Some(bundle) = self.store.store(bundle, data.into()).await {
                break bundle;
            }

            // Duplicate bundle generated by builder - go again
            warn!("Duplicate bundle generated by builder");
        };

        // And process
        let bundle_id = bundle.bundle.id.clone();
        self.dispatch_bundle(bundle).await;

        Ok(bundle_id)
    }

    /// Dispatch a bundle from raw bytes (for low-level Service trait)
    /// Parses and validates the bundle (security boundary)
    #[cfg_attr(feature = "tracing", instrument(skip(self, data)))]
    pub async fn local_dispatch_raw(
        self: &Arc<Self>,
        expected_source: &Eid,
        data: Bytes,
    ) -> Result<hardy_bpv7::bundle::Id, services::Error> {
        // Parse the bundle (security boundary - can't trust service-provided bytes)
        // Use CheckedBundle to canonicalize but preserve all blocks (including unknown extensions)
        let checked = hardy_bpv7::bundle::CheckedBundle::parse(&data, self.key_provider())?;

        // Use rewritten data if canonicalization was needed
        let (parsed, data) = if let Some(new_data) = checked.new_data {
            (checked.bundle, Bytes::from(new_data.into_vec()))
        } else {
            (checked.bundle, data)
        };

        // Verify source matches the registered service endpoint
        // (registration already validated that the EID belongs to our node)
        if &parsed.id.source != expected_source {
            return Err(services::Error::InvalidDestination(
                parsed.id.source.clone(),
            ));
        }

        // Check if ipn_2_element encoding is required for this destination
        let needs_legacy_ipn = self
            .ipn_2_element
            .iter()
            .any(|p| p.matches(&parsed.destination));

        // Apply ipn_2_element rewriting if needed (transparent to service)
        let (parsed, data) = if needs_legacy_ipn {
            let needs_source_rewrite = matches!(parsed.id.source, Eid::Ipn { .. });
            let needs_dest_rewrite = matches!(parsed.destination, Eid::Ipn { .. });

            if needs_source_rewrite || needs_dest_rewrite {
                // Use Editor to rewrite EIDs
                let mut editor = hardy_bpv7::editor::Editor::new(&parsed, &data);

                if needs_source_rewrite
                    && let Eid::Ipn {
                        fqnn,
                        service_number,
                    } = &parsed.id.source
                {
                    editor = editor
                        .with_source(Eid::LegacyIpn {
                            fqnn: fqnn.clone(),
                            service_number: *service_number,
                        })
                        .map_err(|(_, e)| services::Error::Internal(e.into()))?;
                }

                if needs_dest_rewrite
                    && let Eid::Ipn {
                        fqnn,
                        service_number,
                    } = &parsed.destination
                {
                    editor = editor
                        .with_destination(Eid::LegacyIpn {
                            fqnn: fqnn.clone(),
                            service_number: *service_number,
                        })
                        .map_err(|(_, e)| services::Error::Internal(e.into()))?;
                }

                // Rebuild the bundle with rewritten EIDs
                let new_data: Bytes = editor
                    .rebuild()
                    .map_err(|e| services::Error::Internal(e.into()))?
                    .into();

                // Re-parse the rewritten bundle (Editor output is trusted to be correct)
                (
                    hardy_bpv7::bundle::ParsedBundle::parse(&new_data, self.key_provider())?.bundle,
                    new_data,
                )
            } else {
                (parsed, data)
            }
        } else {
            (parsed, data)
        };

        // Store and dispatch (store takes hardy_bpv7::bundle::Bundle)
        if let Some(bundle) = self.store.store(parsed, data).await {
            let bundle_id = bundle.bundle.id.clone();
            self.dispatch_bundle(bundle).await;
            Ok(bundle_id)
        } else {
            // Duplicate bundle
            Err(services::Error::Internal(
                "Duplicate bundle".to_string().into(),
            ))
        }
    }

    pub async fn cancel_local_dispatch(&self, bundle_id: &hardy_bpv7::bundle::Id) -> bool {
        let Some(bundle) = self.store.get_metadata(bundle_id).await else {
            return false;
        };

        // TODO: Need some access control in the metadata here!

        self.delete_bundle(bundle).await;
        true
    }

    #[cfg_attr(feature = "tracing", instrument(skip(self, bundle),fields(bundle.id = %bundle.bundle.id)))]
    pub(super) async fn deliver_bundle(
        self: &Arc<Self>,
        service: Arc<services::registry::Service>,
        bundle: &bundle::Bundle,
    ) -> dispatch::DispatchResult {
        let Some(data) = self.load_data(bundle).await else {
            // Bundle data was deleted sometime during processing
            return dispatch::DispatchResult::Gone;
        };

        match &service.service {
            services::registry::ServiceImpl::LowLevel(svc) => {
                // Pass raw bundle bytes to low-level services
                svc.on_receive(data, bundle.expiry()).await;
            }
            services::registry::ServiceImpl::Application(app) => {
                // Extract and decrypt payload for Application
                // key_source is scoped to ensure it's dropped before await (not Send)
                let payload = {
                    let key_source = self.key_source(&bundle.bundle, &data);
                    match bundle.bundle.block_data(1, &data, &*key_source) {
                        Err(hardy_bpv7::Error::InvalidBPSec(hardy_bpv7::bpsec::Error::NoKey)) => {
                            // TODO: We are unable to decrypt the payload, what do we do?
                            return dispatch::DispatchResult::Wait;
                        }
                        Err(e) => {
                            // Other decryption error - skip delivery
                            debug!("Received an invalid payload: {e}");
                            return dispatch::DispatchResult::Delivered;
                        }
                        Ok(hardy_bpv7::block::Payload::Borrowed(_)) => {
                            data.slice(bundle.bundle.blocks.get(&1).unwrap().payload_range())
                        }
                        Ok(hardy_bpv7::block::Payload::Decrypted(decrypted)) => {
                            Bytes::from_owner(decrypted)
                        }
                    }
                };

                app.on_receive(
                    bundle.bundle.id.source.clone(),
                    bundle.expiry(),
                    bundle.bundle.flags.app_ack_requested,
                    payload,
                )
                .await;
            }
        }
        dispatch::DispatchResult::Delivered
    }
}
