use super::*;

impl Dispatcher {
    #[instrument(skip(self))]
    pub async fn local_dispatch(
        &self,
        mut source: Eid,
        mut destination: Eid,
        data: &[u8],
        lifetime: std::time::Duration,
        flags: Option<service::SendFlags>,
    ) -> Result<hardy_bpv7::bundle::Id, Error> {
        // Check to see if we should use ipn 2-element encoding
        if self.ipn_2_element.contains(&destination) {
            if let Eid::Ipn {
                allocator_id: sa,
                node_number: sn,
                service_number: ss,
            } = source
            {
                source = Eid::LegacyIpn {
                    allocator_id: sa,
                    node_number: sn,
                    service_number: ss,
                };
            }

            if let Eid::Ipn {
                allocator_id: da,
                node_number: dn,
                service_number: ds,
            } = destination
            {
                destination = Eid::LegacyIpn {
                    allocator_id: da,
                    node_number: dn,
                    service_number: ds,
                };
            }
        }

        // Build the bundle
        let mut b = hardy_bpv7::builder::Builder::new();

        // Set flags
        if let Some(flags) = flags {
            b.flags(hardy_bpv7::bundle::Flags {
                do_not_fragment: flags.do_not_fragment,
                app_ack_requested: flags.request_ack,
                report_status_time: flags.report_status_time,
                receipt_report_requested: flags.notify_reception,
                forward_report_requested: flags.notify_forwarding,
                delivery_report_requested: flags.notify_delivery,
                delete_report_requested: flags.notify_deletion,
                ..Default::default()
            });

            if flags.notify_reception
                || flags.notify_forwarding
                || flags.notify_delivery
                || flags.notify_deletion
            {
                b.report_to(self.node_ids.get_admin_endpoint(&destination));
            }
        }
        b.source(source)
            .destination(destination)
            .lifetime(lifetime)
            .add_payload_block(data);

        let (bundle, data) = b.build();
        let bundle_id = bundle.id.clone();

        // Store to store
        let bundle = self
            .store
            .store(bundle, data.into(), None)
            .await?
            .trace_expect("Duplicate bundle generated by builder!");

        // And process
        self.dispatch_bundle(bundle).await.map(|_| bundle_id)
    }

    #[instrument(skip(self, service))]
    pub async fn deliver_bundle(
        &self,
        service: Arc<service_registry::Service>,
        mut bundle: bundle::Bundle,
    ) -> Result<(), Error> {
        let Some(data) = self.load_data(&mut bundle).await? else {
            // Bundle data was deleted sometime during processing - this is benign
            return Ok(());
        };

        let payload = match bundle.bundle.block_payload(1, &data, self)? {
            None => {
                // TODO: We are unable to decrypt the payload, what do we do?
                todo!();
            }
            Some(hardy_bpv7::bundle::Payload::Range(range)) => data.slice(range),
            Some(hardy_bpv7::bundle::Payload::Owned(data)) => Bytes::from_owner(data),
        };

        // Pass the bundle and data to the service
        service
            .service
            .on_receive(service::Bundle {
                id: bundle.bundle.id.to_key(),
                expiry: bundle.expiry(),
                ack_requested: bundle.bundle.flags.app_ack_requested,
                payload,
            })
            .await;

        self.report_bundle_delivery(&bundle).await?;

        // And we are done with the bundle
        self.drop_bundle(bundle, None).await
    }
}
