use super::*;
use hardy_bpv7::status_report::ReasonCode;

impl Dispatcher {
    /// Run Originate filter on a stored bundle.
    /// If the filter drops the bundle, it is deleted and Ok(None) is returned.
    /// If the filter passes or no filter is registered, returns Ok(Some((bundle, data))).
    pub(super) async fn run_originate_filter(
        &self,
        bundle: bundle::Bundle,
        data: Bytes,
    ) -> Result<Option<(bundle::Bundle, Bytes)>, bpa::Error> {
        if self.filter_registry.has_filters(filters::Hook::Originate) {
            match self
                .filter_registry
                .exec(
                    filters::Hook::Originate,
                    bundle,
                    data,
                    self.key_provider(),
                    &self.processing_pool,
                )
                .await?
            {
                filters::registry::ExecResult::Continue(mutation, mut bundle, data) => {
                    self.persist_filter_mutation(mutation, &mut bundle, &data)
                        .await;
                    Ok(Some((bundle, data)))
                }
                filters::registry::ExecResult::Drop(bundle, _reason) => {
                    debug!("Originate filter dropped bundle");
                    self.delete_bundle(bundle).await;
                    Ok(None)
                }
            }
        } else {
            Ok(Some((bundle, data)))
        }
    }

    #[cfg_attr(feature = "tracing", instrument(skip(self, data)))]
    pub async fn local_dispatch(
        self: &Arc<Self>,
        mut source: Eid,
        mut destination: Eid,
        data: Bytes,
        lifetime: std::time::Duration,
        flags: Option<services::SendOptions>,
    ) -> Result<hardy_bpv7::bundle::Id, services::Error> {
        // Check to see if we should use ipn 2-element encoding
        if self.ipn_2_element.iter().any(|p| p.matches(&destination)) {
            if let Eid::Ipn {
                fqnn,
                service_number,
            } = source
            {
                source = Eid::LegacyIpn {
                    fqnn,
                    service_number,
                };
            }

            if let Eid::Ipn {
                fqnn,
                service_number,
            } = destination
            {
                destination = Eid::LegacyIpn {
                    fqnn,
                    service_number,
                };
            }
        }

        // Build and store the bundle
        let (bundle, data) = loop {
            let mut builder =
                hardy_bpv7::builder::Builder::new(source.clone(), destination.clone())
                    .with_lifetime(lifetime);

            // Set flags
            if let Some(flags) = &flags {
                builder = builder.with_flags(hardy_bpv7::bundle::Flags {
                    do_not_fragment: flags.do_not_fragment,
                    app_ack_requested: flags.request_ack,
                    report_status_time: flags.report_status_time,
                    receipt_report_requested: flags.notify_reception,
                    forward_report_requested: flags.notify_forwarding,
                    delivery_report_requested: flags.notify_delivery,
                    delete_report_requested: flags.notify_deletion,
                    ..Default::default()
                });

                if flags.notify_reception
                    || flags.notify_forwarding
                    || flags.notify_delivery
                    || flags.notify_deletion
                {
                    builder =
                        builder.with_report_to(self.node_ids.get_admin_endpoint(&destination));
                }
            }

            let (bundle, encoded_data) = builder
                .with_payload(std::borrow::Cow::Borrowed(&data))
                .build(hardy_bpv7::creation_timestamp::CreationTimestamp::now())
                .map_err(|e| services::Error::Internal(e.into()))?;
            let encoded_data = Bytes::from(encoded_data.into_vec());

            // Store first so bundle has valid metadata for filter
            if let Some(bundle) = self
                .store
                .store(metadata::BundleStatus::New, bundle, &encoded_data)
                .await
            {
                break (bundle, encoded_data);
            }

            // Duplicate bundle generated by builder - go again
            warn!("Duplicate bundle generated by builder");
        };

        // Originate filter hook on stored bundle
        let Some((bundle, data)) = self
            .run_originate_filter(bundle, data)
            .await
            .inspect_err(|e| error!("Originate filter error: {e}"))?
        else {
            return Err(services::Error::Dropped(None));
        };

        let bundle_id = bundle.bundle.id.clone();
        self.ingest_bundle(bundle, data).await;
        Ok(bundle_id)
    }

    /// Dispatch a bundle from raw bytes (for low-level Service trait)
    /// Parses and validates the bundle (security boundary)
    #[cfg_attr(feature = "tracing", instrument(skip(self, data)))]
    pub async fn local_dispatch_raw(
        self: &Arc<Self>,
        expected_source: &Eid,
        data: Bytes,
    ) -> Result<hardy_bpv7::bundle::Id, services::Error> {
        // Parse the bundle (security boundary - can't trust service-provided bytes)
        // Use CheckedBundle to canonicalize but preserve all blocks (including unknown extensions)
        let checked = hardy_bpv7::bundle::CheckedBundle::parse(&data, self.key_provider())?;

        // Use rewritten data if canonicalization was needed
        let (bundle, data) = if let Some(new_data) = checked.new_data {
            (checked.bundle, Bytes::from(new_data.into_vec()))
        } else {
            (checked.bundle, data)
        };

        // Verify source matches the registered service endpoint
        // (registration already validated that the EID belongs to our node)
        if &bundle.id.source != expected_source {
            return Err(services::Error::InvalidDestination(
                bundle.id.source.clone(),
            ));
        }

        // Check if ipn_2_element encoding is required for this destination
        // TODO: Move this to a Filter
        let needs_legacy_ipn = self
            .ipn_2_element
            .iter()
            .any(|p| p.matches(&bundle.destination));

        // Apply ipn_2_element rewriting if needed (transparent to service)
        let (bundle, data) = if needs_legacy_ipn {
            let needs_source_rewrite = matches!(bundle.id.source, Eid::Ipn { .. });
            let needs_dest_rewrite = matches!(bundle.destination, Eid::Ipn { .. });

            if needs_source_rewrite || needs_dest_rewrite {
                // Use Editor to rewrite EIDs
                let mut editor = hardy_bpv7::editor::Editor::new(&bundle, &data);

                if needs_source_rewrite
                    && let Eid::Ipn {
                        fqnn,
                        service_number,
                    } = &bundle.id.source
                {
                    editor = editor
                        .with_source(Eid::LegacyIpn {
                            fqnn: fqnn.clone(),
                            service_number: *service_number,
                        })
                        .map_err(|(_, e)| services::Error::Internal(e.into()))?;
                }

                if needs_dest_rewrite
                    && let Eid::Ipn {
                        fqnn,
                        service_number,
                    } = &bundle.destination
                {
                    editor = editor
                        .with_destination(Eid::LegacyIpn {
                            fqnn: fqnn.clone(),
                            service_number: *service_number,
                        })
                        .map_err(|(_, e)| services::Error::Internal(e.into()))?;
                }

                // Rebuild the bundle with rewritten EIDs
                let new_data: Bytes = editor
                    .rebuild()
                    .map_err(|e| services::Error::Internal(e.into()))?
                    .into();

                // Re-parse the rewritten bundle (Editor output is trusted to be correct)
                (
                    hardy_bpv7::bundle::ParsedBundle::parse(&new_data, self.key_provider())?.bundle,
                    new_data,
                )
            } else {
                (bundle, data)
            }
        } else {
            (bundle, data)
        };

        // Store first so bundle has valid metadata for filter
        let Some(bundle) = self
            .store
            .store(metadata::BundleStatus::New, bundle, &data)
            .await
        else {
            // Duplicate bundle
            return Err(services::Error::Internal(
                "Duplicate bundle".to_string().into(),
            ));
        };

        // Originate filter hook on stored bundle
        let Some((bundle, data)) = self
            .run_originate_filter(bundle, data)
            .await
            .inspect_err(|e| error!("Originate filter error: {e}"))?
        else {
            return Err(services::Error::Dropped(None));
        };

        let bundle_id = bundle.bundle.id.clone();
        self.ingest_bundle(bundle, data).await;
        Ok(bundle_id)
    }

    pub async fn cancel_local_dispatch(&self, bundle_id: &hardy_bpv7::bundle::Id) -> bool {
        let Some(bundle) = self.store.get_metadata(bundle_id).await else {
            return false;
        };

        // TODO: Need some access control in the metadata here!

        self.delete_bundle(bundle).await;
        true
    }

    #[cfg_attr(feature = "tracing", instrument(skip(self, bundle),fields(bundle.id = %bundle.bundle.id)))]
    pub(super) async fn deliver_bundle(
        &self,
        service: Arc<services::registry::Service>,
        bundle: bundle::Bundle,
        data: Bytes,
    ) {
        // Deliver filter hook
        // Clone is required here because process_bundle passes &bundle and needs it for other arms.
        // The clone only happens when filters are registered.
        let (bundle, data) = if self.filter_registry.has_filters(filters::Hook::Deliver) {
            match self
                .filter_registry
                .exec(
                    filters::Hook::Deliver,
                    bundle,
                    data,
                    self.key_provider(),
                    &self.processing_pool,
                )
                .await
                .trace_expect("Deliver filter execution failed")
            {
                filters::registry::ExecResult::Continue(_mutation, bundle, data) => (bundle, data),
                filters::registry::ExecResult::Drop(bundle, reason) => {
                    return self.drop_bundle(bundle, reason).await;
                }
            }
        } else {
            (bundle, data)
        };

        match &service.service {
            services::registry::ServiceImpl::LowLevel(svc) => {
                // Pass raw bundle bytes to low-level services
                svc.on_receive(data, bundle.expiry()).await;
            }
            services::registry::ServiceImpl::Application(app) => {
                // Extract and decrypt payload for Application
                let payload_result = {
                    let key_source = self.key_source(&bundle.bundle, &data);
                    bundle.bundle.block_data(1, &data, &*key_source)
                }; // key_source dropped here, before any await

                let payload = {
                    match payload_result {
                        Err(hardy_bpv7::Error::InvalidBPSec(hardy_bpv7::bpsec::Error::NoKey)) => {
                            // TODO: We are unable to decrypt the payload, what do we do?
                            debug!("Failed to decrypt payload: No valid keys");
                            return self.store.watch_bundle(bundle).await;
                        }
                        Err(e) => {
                            // Other decryption error - skip delivery
                            debug!("Received an invalid payload: {e}");

                            // TODO: This is where we can wrap the damaged bundle in a "Junk Bundle Payload" and forward it to a 'lost+found' endpoint.  For now we just drop it.

                            return self
                                .drop_bundle(bundle, Some(ReasonCode::BlockUnintelligible))
                                .await;
                        }
                        Ok(hardy_bpv7::block::Payload::Borrowed(_)) => {
                            data.slice(bundle.bundle.blocks.get(&1).unwrap().payload_range())
                        }
                        Ok(hardy_bpv7::block::Payload::Decrypted(decrypted)) => {
                            Bytes::from_owner(decrypted)
                        }
                    }
                };

                app.on_receive(
                    bundle.bundle.id.source.clone(),
                    bundle.expiry(),
                    bundle.bundle.flags.app_ack_requested,
                    payload,
                )
                .await;
            }
        }

        self.report_bundle_delivery(&bundle).await;
        self.drop_bundle(bundle, None).await
    }
}
