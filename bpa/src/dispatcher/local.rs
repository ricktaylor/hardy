use super::*;

impl Dispatcher {
    #[instrument(skip(self))]
    pub async fn local_dispatch(
        &self,
        mut source: bpv7::Eid,
        mut destination: bpv7::Eid,
        data: &[u8],
        lifetime: time::Duration,
        flags: Option<service::SendFlags>,
    ) -> Result<bpv7::BundleId, Error> {
        // Check to see if we should use ipn 2-element encoding
        if let bpv7::Eid::Ipn {
            allocator_id: da,
            node_number: dn,
            service_number: ds,
        } = destination
        {
            // Check configured entries
            if self.ipn_2_element.contains(&destination) {
                if let bpv7::Eid::Ipn {
                    allocator_id: sa,
                    node_number: sn,
                    service_number: ss,
                } = source
                {
                    source = bpv7::Eid::LegacyIpn {
                        allocator_id: sa,
                        node_number: sn,
                        service_number: ss,
                    };
                }
                destination = bpv7::Eid::LegacyIpn {
                    allocator_id: da,
                    node_number: dn,
                    service_number: ds,
                };
            }
        }

        // Build the bundle
        let mut b = bpv7::Builder::new();

        // Set flags
        if let Some(flags) = flags {
            b.report_to(
                self.admin_endpoints
                    .get_admin_endpoint(&destination)
                    .clone(),
            )
            .flags(bpv7::BundleFlags {
                do_not_fragment: flags.do_not_fragment,
                app_ack_requested: flags.request_ack,
                report_status_time: flags.report_status_time,
                receipt_report_requested: flags.notify_reception,
                forward_report_requested: flags.notify_forwarding,
                delivery_report_requested: flags.notify_delivery,
                delete_report_requested: flags.notify_deletion,
                ..Default::default()
            });
        }
        b.source(source)
            .destination(destination)
            .lifetime(lifetime)
            .add_payload_block(data.into());

        let (bundle, data) = b.build();
        let bundle_id = bundle.id.clone();

        // Store to store
        let metadata = self
            .store
            .store(&bundle, &data, BundleStatus::default(), None)
            .await?
            .trace_expect("Duplicate bundle generated by builder!");

        // And process
        self.process_bundle(bundle::Bundle { metadata, bundle })
            .await
            .map(|_| bundle_id)
    }
}
