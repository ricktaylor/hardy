use super::*;

impl Dispatcher {
    #[cfg_attr(feature = "tracing", instrument(skip(self, data)))]
    pub async fn local_dispatch(
        self: &Arc<Self>,
        mut source: Eid,
        mut destination: Eid,
        data: &[u8],
        lifetime: std::time::Duration,
        flags: Option<service::SendOptions>,
    ) -> Result<hardy_bpv7::bundle::Id, service::Error> {
        // Check to see if we should use ipn 2-element encoding
        if self.ipn_2_element.iter().any(|p| p.matches(&destination)) {
            if let Eid::Ipn {
                allocator_id: sa,
                node_number: sn,
                service_number: ss,
            } = source
            {
                source = Eid::LegacyIpn {
                    allocator_id: sa,
                    node_number: sn,
                    service_number: ss,
                };
            }

            if let Eid::Ipn {
                allocator_id: da,
                node_number: dn,
                service_number: ds,
            } = destination
            {
                destination = Eid::LegacyIpn {
                    allocator_id: da,
                    node_number: dn,
                    service_number: ds,
                };
            }
        }

        // Build the bundle
        let bundle = loop {
            let mut builder =
                hardy_bpv7::builder::Builder::new(source.clone(), destination.clone())
                    .with_lifetime(lifetime);

            // Set flags
            if let Some(flags) = &flags {
                builder = builder.with_flags(hardy_bpv7::bundle::Flags {
                    do_not_fragment: flags.do_not_fragment,
                    app_ack_requested: flags.request_ack,
                    report_status_time: flags.report_status_time,
                    receipt_report_requested: flags.notify_reception,
                    forward_report_requested: flags.notify_forwarding,
                    delivery_report_requested: flags.notify_delivery,
                    delete_report_requested: flags.notify_deletion,
                    ..Default::default()
                });

                if flags.notify_reception
                    || flags.notify_forwarding
                    || flags.notify_delivery
                    || flags.notify_deletion
                {
                    builder =
                        builder.with_report_to(self.node_ids.get_admin_endpoint(&destination));
                }
            }

            let (bundle, data) = builder
                .with_payload(data.into())
                .build(hardy_bpv7::creation_timestamp::CreationTimestamp::now())
                .map_err(|e| service::Error::Internal(e.into()))?;

            // Store to store
            if let Some(bundle) = self.store.store(bundle, data.into()).await {
                break bundle;
            }

            // Duplicate bundle generated by builder - go again
            warn!("Duplicate bundle generated by builder");
        };

        // And process
        let bundle_id = bundle.bundle.id.clone();
        self.dispatch_bundle(bundle).await;

        Ok(bundle_id)
    }

    pub async fn cancel_local_dispatch(&self, bundle_id: &hardy_bpv7::bundle::Id) -> bool {
        let Some(bundle) = self.store.get_metadata(bundle_id).await else {
            return false;
        };

        // TODO: Need some access control in the metadata here!

        self.delete_bundle(bundle).await;
        true
    }

    #[cfg_attr(feature = "tracing", instrument(skip(self, bundle),fields(bundle.id = %bundle.bundle.id)))]
    pub(super) async fn deliver_bundle(
        self: &Arc<Self>,
        service: Arc<service_registry::Service>,
        bundle: &bundle::Bundle,
    ) -> dispatch::DispatchResult {
        let Some(data) = self.load_data(bundle).await else {
            // Bundle data was deleted sometime during processing
            return dispatch::DispatchResult::Gone;
        };

        let payload = match bundle.bundle.block_data(1, &data, self.key_store()) {
            Err(hardy_bpv7::Error::InvalidBPSec(hardy_bpv7::bpsec::Error::NoValidKey)) => {
                // TODO: We are unable to decrypt the payload, what do we do?
                return dispatch::DispatchResult::Wait;
            }
            Err(e) => {
                debug!("Received an invalid payload: {e}");
                return dispatch::DispatchResult::Drop(Some(ReasonCode::BlockUnintelligible));
            }
            Ok(hardy_bpv7::block::Payload::Borrowed(_)) => {
                data.slice(bundle.bundle.blocks.get(&1).unwrap().payload_range())
            }
            Ok(hardy_bpv7::block::Payload::Decrypted(data)) => Bytes::from_owner(data),
        };

        // Pass the bundle and data to the service
        service
            .service
            .on_receive(service::Bundle {
                source: bundle.bundle.id.source.clone(),
                expiry: bundle.expiry(),
                ack_requested: bundle.bundle.flags.app_ack_requested,
                payload,
            })
            .await;

        // And we are done with the bundle
        dispatch::DispatchResult::Delivered
    }
}
