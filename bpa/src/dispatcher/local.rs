use super::*;
use hardy_bpv7::status_report::ReasonCode;

impl Dispatcher {
    /// Run Originate filter on an in-memory bundle (not yet stored).
    /// If the filter drops the bundle, Ok(None) is returned.
    /// If the filter passes or no filter is registered, returns Ok(Some((bundle, data))).
    ///
    /// This is a pure in-memory operation - no persistence occurs here.
    /// The caller is responsible for storing the bundle after filtering.
    async fn run_originate_filter(
        &self,
        bundle: bundle::Bundle,
        data: Bytes,
    ) -> Result<Option<(bundle::Bundle, Bytes)>, bpa::Error> {
        match self
            .filter_registry
            .exec(
                filters::Hook::Originate,
                bundle,
                data,
                self.key_provider(),
                &self.processing_pool,
            )
            .await
            .inspect_err(|_e| error!("Originate filter execution failed"))?
        {
            filters::registry::ExecResult::Continue(_mutation, bundle, data) => {
                Ok(Some((bundle, data)))
            }
            filters::registry::ExecResult::Drop(_bundle, _reason) => Ok(None),
        }
    }

    #[cfg_attr(feature = "tracing", instrument(skip(self, payload)))]
    pub async fn local_dispatch(
        self: &Arc<Self>,
        source: Eid,
        destination: Eid,
        payload: Bytes,
        lifetime: std::time::Duration,
        flags: Option<services::SendOptions>,
    ) -> Result<hardy_bpv7::bundle::Id, services::Error> {
        // Build bundle and run Originate filter before storing
        loop {
            let mut builder =
                hardy_bpv7::builder::Builder::new(source.clone(), destination.clone())
                    .with_lifetime(lifetime);

            // Set flags
            if let Some(flags) = &flags {
                builder = builder.with_flags(hardy_bpv7::bundle::Flags {
                    do_not_fragment: flags.do_not_fragment,
                    app_ack_requested: flags.request_ack,
                    report_status_time: flags.report_status_time,
                    receipt_report_requested: flags.notify_reception,
                    forward_report_requested: flags.notify_forwarding,
                    delivery_report_requested: flags.notify_delivery,
                    delete_report_requested: flags.notify_deletion,
                    ..Default::default()
                });

                if flags.notify_reception
                    || flags.notify_forwarding
                    || flags.notify_delivery
                    || flags.notify_deletion
                {
                    builder =
                        builder.with_report_to(self.node_ids.get_admin_endpoint(&destination));
                }
            }

            let (bundle, data) = builder
                .with_payload(std::borrow::Cow::Borrowed(&payload))
                .build(hardy_bpv7::creation_timestamp::CreationTimestamp::now())
                .map_err(|e| services::Error::Internal(e.into()))?;

            let r = self.originate_bundle(bundle, Bytes::from(data)).await;
            if !matches!(r, Err(services::Error::DuplicateBundle)) {
                break r;
            }

            warn!("Duplicate bundle generated by builder, retrying with new timestamp");
        }
    }

    /// Dispatch a bundle from raw bytes (for low-level Service trait)
    /// Parses and validates the bundle (security boundary)
    #[cfg_attr(feature = "tracing", instrument(skip(self, data)))]
    pub async fn local_dispatch_raw(
        self: &Arc<Self>,
        expected_source: &Eid,
        data: Bytes,
    ) -> Result<hardy_bpv7::bundle::Id, services::Error> {
        // Parse the bundle (security boundary - can't trust service-provided bytes)
        // Use CheckedBundle to canonicalize but preserve all blocks (including unknown extensions)
        let checked = hardy_bpv7::bundle::CheckedBundle::parse(&data, self.key_provider())?;

        // Use rewritten data if canonicalization was needed
        let (bundle, data) = if let Some(new_data) = checked.new_data {
            (checked.bundle, Bytes::from(new_data))
        } else {
            (checked.bundle, data)
        };

        // Verify source matches the registered service endpoint
        // (registration already validated that the EID belongs to our node)
        if &bundle.id.source != expected_source {
            return Err(services::Error::InvalidDestination(
                bundle.id.source.clone(),
            ));
        }

        self.originate_bundle(bundle, data).await
    }

    async fn originate_bundle(
        self: &Arc<Self>,
        bundle: hardy_bpv7::bundle::Bundle,
        data: Bytes,
    ) -> Result<hardy_bpv7::bundle::Id, services::Error> {
        // Wrap in bundle::Bundle with initial metadata (not stored yet)
        let bundle = bundle::Bundle {
            metadata: metadata::BundleMetadata {
                status: metadata::BundleStatus::New,
                ..Default::default()
            },
            bundle,
        };

        // Run Originate filter (pure in-memory)
        let Some((mut bundle, data)) = self
            .run_originate_filter(bundle, data)
            .await
            .inspect_err(|e| error!("Originate filter error: {e}"))?
        else {
            return Err(services::Error::Dropped(None));
        };

        // Now store (single persist operation, preserves filter-modified metadata)
        if !self.store.store(&mut bundle, &data).await {
            return Err(services::Error::DuplicateBundle);
        }

        let bundle_id = bundle.bundle.id.clone();
        self.ingest_bundle(bundle, data).await;
        Ok(bundle_id)
    }

    pub async fn cancel_local_dispatch(&self, bundle_id: &hardy_bpv7::bundle::Id) -> bool {
        let Some(bundle) = self.store.get_metadata(bundle_id).await else {
            return false;
        };

        // TODO: Need some access control in the metadata here!

        self.delete_bundle(bundle).await;
        true
    }

    #[cfg_attr(feature = "tracing", instrument(skip(self, bundle),fields(bundle.id = %bundle.bundle.id)))]
    pub(super) async fn deliver_bundle(
        &self,
        service: Arc<services::registry::Service>,
        bundle: bundle::Bundle,
        data: Bytes,
    ) {
        // Deliver filter hook
        let (bundle, data) = match self
            .filter_registry
            .exec(
                filters::Hook::Deliver,
                bundle,
                data,
                self.key_provider(),
                &self.processing_pool,
            )
            .await
            .trace_expect("Deliver filter execution failed")
        {
            filters::registry::ExecResult::Continue(_mutation, bundle, data) => (bundle, data),
            filters::registry::ExecResult::Drop(bundle, reason) => {
                return self.drop_bundle(bundle, reason).await;
            }
        };

        match &service.service {
            services::registry::ServiceImpl::LowLevel(svc) => {
                // Pass raw bundle bytes to low-level services
                svc.on_receive(data, bundle.expiry()).await;
            }
            services::registry::ServiceImpl::Application(app) => {
                // Extract and decrypt payload for Application
                let payload_result = {
                    let key_source = self.key_source(&bundle.bundle, &data);
                    bundle.bundle.block_data(1, &data, &*key_source)
                }; // key_source dropped here, before any await

                let payload = {
                    match payload_result {
                        Err(hardy_bpv7::Error::InvalidBPSec(hardy_bpv7::bpsec::Error::NoKey)) => {
                            // TODO: We are unable to decrypt the payload, what do we do?
                            debug!("Failed to decrypt payload: No valid keys");
                            return self.store.watch_bundle(bundle).await;
                        }
                        Err(e) => {
                            // Other decryption error - skip delivery
                            debug!("Received an invalid payload: {e}");

                            // TODO: This is where we can wrap the damaged bundle in a "Junk Bundle Payload" and forward it to a 'lost+found' endpoint.  For now we just drop it.

                            return self
                                .drop_bundle(bundle, Some(ReasonCode::BlockUnintelligible))
                                .await;
                        }
                        Ok(hardy_bpv7::block::Payload::Borrowed(_)) => {
                            data.slice(bundle.bundle.blocks.get(&1).unwrap().payload_range())
                        }
                        Ok(hardy_bpv7::block::Payload::Decrypted(decrypted)) => {
                            Bytes::from_owner(decrypted)
                        }
                    }
                };

                app.on_receive(
                    bundle.bundle.id.source.clone(),
                    bundle.expiry(),
                    bundle.bundle.flags.app_ack_requested,
                    payload,
                )
                .await;
            }
        }

        self.report_bundle_delivery(&bundle).await;
        self.drop_bundle(bundle, None).await
    }
}
